{"pages":[{"title":"关于我：","text":"一个想混入互联网的momo,结果GitHub当初使用了全名。 个人介绍 慕溪是我过去工作的花名，我喜欢这个名字，所以你可以叫我慕溪。 98年，2021年毕业，目前从事前端开发工作，base杭州。 兴趣爱好我的兴趣爱好很广泛 喜欢养花，熟悉很多种鲜花名字 喜欢画画 想去学吉他，到现在还没开始动手 喜欢猫猫和狗狗 特点 容易一边内耗一边自我拯救 争取做一个不自我内耗的人 最近get到 互联网发疯真是个解压的事情","link":"/about/index.html"},{"title":"","text":"","link":"/links/index.html"}],"posts":[{"title":"myFirstBlog","text":"这是我的第一个博客","link":"/2023/11/02/myFirstBlog/"},{"title":"【技术】this指针、闭包、作用域","text":"this大家都在说this,this是什么？– js的运行环境。首先我们要知道，一个系统System的状态分为两种： 静态创建态 语义分析 （作用域链、变量声明） 动态执行态 this/context/指针 变量使用 函数引用 作用域链 + 上下文 面试常问作用域链，作用域链是什么？ –子可调用父的东西，作用域链向上找。 函数提升 ： 提升至当前作用域最初始 变量提升 ： 提升至当前作用域最初始 提升的优先级 ： 变量优先于函数 对于作用域链，我们直接通过创建态来定位作用域链。 this 上下文 context 我家门前有条河，门前的河上有做桥，合理有群鸭。 我家门前有条河，「这河」上有座桥，「这河」里有群鸭。 this是在执行时动态读取上下文决定的，而不是创建时 重点 - 各使用态中的指针指向 函数直接调用 - this指向的是window =&gt; 函数表达式、匿名函数、嵌套函数例： 1234function foo() { console.log('函数内部的this', this);}foo() 隐式绑定 - this指向的是调用的上一级 =&gt; 对象、数组等引用关系逻辑之上例： 123456789function fn() { console.log('隐式绑定', this.a);}const obj = { a: 1, fn}obj.fn = fn;obj.fn(); 面试题：1234567891011121314151617181920212223242526272829303132333435363738const foo = { bar: 100, fn: function() { console.log(this.bar); console.log(this); }}// 取出let fn1 = foo.fn；// 执行fn1();// 追问1：如何改变属性的指向const o1 = { text: 'o1', fn: function() { // 直接使用上下文 - 领导直接分活 console.log('o1fn_this', this); return this.text; }}const o2 = { text: 'o2', fn: function() { // 呼叫了隔壁组leader协助执行 - 部门协作 return o1.fn(); }}const o3 = { text: 'o3', fn: function() { // 直接内部构造 - 接口人制度 let fn = o1.fn; return fn(); // 最终执行 }}console.log('o1fn', o1.fn());console.log('o2fn', o2.fn());console.log('o3fn', o3.fn()); 在执行函数时，函数被上一级调用，去找发起方 直接变成公共执行时，指向全局 追问2：就是要把console.log(‘o2fn’, o2.fn())结果是o212345678910111213141516// 1. 人为干涉，改变this - bind / call / applyo1.fn.call(o2);// 2. 不许人为干涉const o1 = { text: 'o1', fn: function() { // 直接使用上下文 - 领导直接分活 console.log('o1fn_this', this); return this.text; }}const o2 = { text: 'o2', fn: o1.fn} console.log('o2fn', o2.fn()); 显式绑定（bind | apply | call）123456789101112131415function foo() { console.log('函数内部的this', this);}foo();// 使用foo.call({ a: 1});foo.apply({ a: 1})const bindFoo = foo.bind({ a: 1})bindFoo(); 追问：call、apply、bind的区别 call &lt;=&gt; apply 传参不同 依次传入/数组传入 bind &lt; = &gt; call/apply 直接返回,而bind返回修改this后的函数，需要自己去执行；这三个第一个参数都是this的指向，call和bind传参相同，多个参数依次传入的；只有apply接收的数组； call和apply都是对函数进行直接调用，而bind方法不会立即调用函数(所以要手动调用下，前两个是主动调用)，而是返回一个修改this后的函数。 追问2：bind原理 / 手写bind 原理或者手写类题目，解题思路 说明原理 - 写注释 根据注释 - 补齐代码1234567891011121314151617181920212223242526272829// 1. 需求：手写bind =&gt; bind存放位置（挂载）=&gt; Function.prototypeFunction.prototype.newBind = function() {// 2. bind是什么？=&gt; 改变运行上下文 =&gt; 传入参数：newThis + args1~argsn const _this = this; const args = Array.prototype.slice.call(arguments); const newThis = args.shift();// 3. bind要什么？=&gt; 返回一个可执行函数 =&gt; 上下文被改变了的原函数（原函数参数不变） return function() { return _this.apply(newThis, args); }}Function.prototype.newApply = function(context) { // 边缘检测 // 函数检测 if(typeof this !== 'function') { throw new Error('type error'); } // 参数检测 context = context || window; // 临时挂载 context.fn = this; // 区分传参 + 立即执行 let result = arguments[1] ? context.fn(...arguments[1]) : context.fn() // 销毁临时挂载 delete context.fn; return result;} 123456789101112131415161718192021Array.prototype.slice.call(arguments) 到底做了什么？function foo() { console.log(arguments) console.log(Array.prototype.slice.call(arguments))}foo(1,2,3)；// {0:1,1:2,2:3,length:3}// [1,2,3]因为arguments是一个array-like（类数组）对象；除了这样写，也可以使用...rest解构，也可以使用Array.from(...)console.log(Array.from('foo'));// Expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], (x) =&gt; x + x));// Expected output: Array [2, 4, 6]Array.from() 静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。slice() 方法返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变。shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 注意： 此方法改变数组的长度！ 提示: 移除数组末尾的元素可以使用pop() 方法。 new - this指向是new之后得到的实例1234567891011class Course { constructor(name) { this.name = name; console.log('构造函数中的this:', this); } test() { console.log('类方法中的this', this); }}const course = new Course('this');course.test(); 追问：类中异步方法，this有区别吗123456789101112131415161718192021class Course { constructor(name) { this.name = name; console.log('构造函数中的this:', this); } test() { console.log('类方法中的this', this); } asyncTest() { console.log('异步方法外：', this); setTimeout(function() { console.log('异步方法内', this); }, 500) ajax.get().then(res =&gt; { // 异步方法 }) }}const course = new Course('this');course.test();course.asyncTest(); 执行setTimeout时，匿名方法执行上下文，在队列中和全局执行函数效果相同 - 指向window 再追问，如何解决 - 记录this / 显式 / 箭头函数 聊完作用域、上下文 =&gt; 如何突破束缚？面试常问必问话题，什么是闭包？ 闭包：一个函数和他周围状态的引用捆绑在一起的组合闭包场景： 函数作为返回值的场景 12345678function mail() { let content = '信'; return function() { console.log(content); }}const envelop = mail();envelop(); 函数可以作为返回值传递的 函数外部可以通过一定方式获取到内部局部作用域的变量 =&gt; 导致内部局部变量不能被GC 函数作为参数的时候 123456789101112// 单一职责let content;// 通用存储function envelop(fn) { content = 1; fn()}// 业务逻辑function mail() { console.log(content);}envelop(mail); 函数嵌套 123456789let counter = 0;function outerFn() { function innerFn() { counter++; console.log(counter); } return innerFn;}outerFn()(); 事件处理（异步）的闭包 12345678let lis = document.getElementsByTagName('li');for(var i = 0; i&lt;lis.length; i++) { (function(i) { lis[i].onclick = function() { console.log(i); } })(i);} 追问：立即执行函数 / 立即执行嵌套 =&gt; 拥有独立作用域 12345(function immediateA(a) { return (function immediateB(b) { console.log(a); })(1);})(0); 推动了js的模块化发展 实现私有变量 - 高频1234567891011121314151617181920212223function createStack() { return { items: [], push(item) { this.items.push(item); } }}const stack = { items: [], push: function() {}}function createStack() { const items = []; return { push(item) { items.push(item); } setItems() {}, getItems() {} }}","link":"/2023/11/02/this/"},{"title":"【心情】情绪边界","text":"1.知道自己的边界在哪，明白自己的情绪反应，尊重边界，而不是去合理化这个感觉。否则这个反馈体系就没有意义了，万劫不复。对方给你的暴力要反馈出来。 当对方给你的暴力，你没有表达出来的时候，你就会反过头来伤害自己。 2.信任自己的情绪。当你觉得不适的时候，就要告诉自己:你的边界被侵犯了。 3.交流的意义不是在于说我们要去辩论谁到底是拥有真理的，而是说我们一起交流我们才能把自己的想法变得更清晰一些。 4.我们的存在先于意义，我所做的才是意义所在。我在表达观点，并不意味着我是一个什么样的人。","link":"/2023/11/02/mind-20231102/"},{"title":"【心情】技术博客出现的第二天，变日记博","text":"昨天晚上更了一篇博客之后，发现写一篇真累，我归结为我不太熟悉Markdown语法，来回调整样式真麻烦。 于是今天我发现了好几个很方便可视化编辑文档之后，直接可以复制出来md格式的，实际上很多笔记软件现在应该都支持这样的，我在这里首推一下有道云。 但是，仍旧觉得写一篇技术文好累的感觉。主要还是我菜，知识并不连贯的，贴出来的代码，我也不一定能再默写出来一遍。 所以，最近来说，可能它会是一个日记博客的可能性更大一些。 记录一些心情也没什么不好，虽说这样我发微博也一样。 不过这样想想，技术笔记不发博客，记在我自己有道云或者掘金那也一样吼。","link":"/2023/11/03/mind-20231103/"},{"title":"【技术】工作记录使用片段《一》","text":"记录本次工作遇到的方便以后快捷复用的情况这两周天天都在跟设计battle，每天到晚量着像素改，可真是给我累坏了。明明页面也不好看，但是要你一个像素都不能差。 总结一下此次开发遇到的一些情况，方便我以后复用。 1、阿里图标库的另类引用方法，适合项目组图标批量引用 可能很多人用阿里图标库，都是直接下载对应Svg或者Png图片到本地的比较多，不过对于图片很多的时候，会显得很麻烦。 所以对于一些成组的比较多的图片，我们为了方便，可以直接下载整个代码文件到本地，放到入口文件之后，只需要使用名称即可使用icon，很方便。 在你的项目图标中，选择下载至本地，然后将下载好的文件解压，并拖入到你的工程代码放图片的目录下； 重新命名为iconfont,总归不能是很长一串的文件名嘛～ 使用时，则将该文件引入到你工程代码的主入口中。import &quot;@/assets/iconfontxx/iconfontxx.css&quot;然后在你需要使用的页面，如下 &lt;span class=&quot;icon iconfont icon-test&quot; /&gt; 即可正常展示。 2、Form表单项嵌套不能显示小红点时，自定义显示小红点，用作必填的提示； 1234567891011121314151617181920212223&lt;Form.Item label=&quot;范围&quot;className=&quot;nesting-form-item&quot;&gt; &lt;Form.Item name=&quot;aaa&quot; rules={[{ required: true, message: '请输入aaa!' }]} noStyle &gt; &lt;Select placeholder=&quot;请选择&quot; onChange={() =&gt; {}} allowClear options={judgeData} style={{ width: '30%', marginRight: '5px' }} &gt;&lt;/Select&gt; &lt;/Form.Item&gt; &lt;Form.Item name=&quot;bbb&quot; rules={[{ required: true, message: '请输入bbb!' }]} noStyle &gt; &lt;InputNumber style={{ width: '50%', marginRight: '5px' }} /&gt; &lt;/Form.Item&gt; &lt;span&gt; 次&lt;/span&gt;&lt;/Form.Item&gt; 解决：在最外层的 Form.Item 加一个类，自己添加 * 号，这里添加的类是 nesting-form-item，定义如下： 12345678910111213.nesting-form-item { .ant-form-item-label &gt; { ::before { display: inline-block; margin-right: 4px; color: #ff4d4f; font-size: 14px; font-family: SimSun, sans-serif; line-height: 1; content: '*'; } }} 此实现参考csdn上 作者https://blog.csdn.net/yiguoxiaohai/article/details/121166912 3、版本号形式X.X.X校验，而且只能支持输入数字，如 12.5.6 123456789101112131415161718 // 自定义校验规则const validateVersionTest = (rule, value, callback) =&gt; { const versionCategory = addForm.getFieldValue(&quot;versionCategory&quot;) if (value &amp;&amp; !/^(\\d+)\\.(\\d+)\\.(\\d+)$/.test(value)) { // 不通过 callback('请填写正确的版本号格式（x.x.x）'); } else if (value &amp;&amp; versionCategory === 0 &amp;&amp; (value.split('.')[1] !== '0' || value.split('.')[2] !== '0')) { // 不通过：下拉选择&quot;大版本&quot;时，第二位和第三位必须为0 callback('选择大版本，第二位和第三位必须为0'); } else if (value &amp;&amp; versionCategory &amp;&amp; versionCategory === 1 &amp;&amp; value.split('.')[2] !== '0') { // 不通过：下拉选择&quot;主版本&quot;时，第三位必须为0 callback('选择主版本，第三位必须为0'); } else { // 通过 callback(); }}; 4、react函数组件中，使用forceUpdate,强制更新 1const [ignored, forceUpdate] = useReducer((x) =&gt; x + 1, 0) 你可以在任何需要强制更新的操作步骤后面，去执行forceUpdate() 5、React函数组件结合antd Input组件实现IP协议输入框需要用到三个Input或者三个InputNumber 效果如图： 12345678910111213141516 &lt;div className='ip-protocol-input-wrap'&gt; &lt;div className={type=== &quot;EDIT&quot;?&quot;ip-protocol-input-disabled&quot;:'ip-protocol-input'}&gt; &lt;Form.Item name='0' noStyle &gt; &lt;InputNumber min={0} className='dot-input' /&gt; &lt;/Form.Item&gt; &lt;span className='dot-span' &gt;.&lt;/span&gt; &lt;Form.Item name='1' noStyle &gt; &lt;InputNumber min={0} className='dot-input' /&gt; &lt;/Form.Item&gt; &lt;span className='dot-span' &gt;.&lt;/span&gt; &lt;Form.Item name='2' noStyle &gt; &lt;InputNumber min={0} className='dot-input' /&gt; &lt;/Form.Item&gt; &lt;/div&gt;&lt;/div&gt; 需要进行处理的CSS样式如下：包含对输入框色块统一、输入光标以及内容居中展示； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697.ip-protocol-input { display: flex; justify-content: space-between; align-items: center; width: 190px; height: 32px; border: 1px solid #d9d9d9; background-color: #ffffff !important; border-radius: 4px; padding: 0 10px; box-sizing: border-box; font-size: 16px; } .ip-protocol-input .dot-input { width: 40px; height: 90%; border: none; outline: none; font-size: 16px; background-color: #ffffff !important; text-align: center; } .ip-protocol-input .dot-span { font-size: 16px; } .ant-input:-webkit-autofill { box-shadow: 0 0 0px 1000px transparent inset !important; } .ant-input:-internal-autofill-previewed { transition: background-color 5000s ease-in-out 0s !important; } .ant-input-number:hover .ant-input-number-handler-wrap { display: none; } .ant-input-number-input { width: 100%; height: 30px; padding: 0px; text-align: left; background-color: transparent; border: 0; border-radius: 2px; outline: 0; -webkit-transition: all .3s linear; transition: all .3s linear; }//禁用时色块统一为灰色 .ip-protocol-input-disabled { background-color: #f5f5f5 !important; display: flex; justify-content: space-between; align-items: center; width: 190px; height: 32px; border: 1px solid #d9d9d9; border-radius: 4px; padding: 0 10px; box-sizing: border-box; font-size: 16px; } .ip-protocol-input-disabled .dot-input { width: 40px; height: 90%; border: none; outline: none; font-size: 16px; background-color: #ffffff !important; text-align: center; } .ant-input-number-input { text-align: center; } .ip-protocol-input-disabled .dot-span { font-size: 16px; } .ant-input-number-disabled .ant-input-number-input { background-color: #f5f5f5 !important; margin-top: -2px; } 6、React函数组件实现antd Input输入onChange获取结果防抖 1234567const handleChange=debounce((value)=&gt;{ //这里处理函数内部逻辑... setValue('xxx')},500)//使用onChange={(value) =&gt; handleChange(value)}","link":"/2023/11/30/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95%E4%BD%BF%E7%94%A8%E7%89%87%E6%AE%B51/"},{"title":"【心情】2023年终总结","text":"首先可以给一个很靠谱的一句总结：2023的一年里，三分之二的时间里我都在不开心。 这种不开心，可能又有一半来源于自己的认知不够+内耗。 希望2024年里，我可以成为一个更多开心的人。 职场变化 因为自己的认知不够，在23年从司内产品开发转向医疗业务开发时候，我觉得好像失去了自己很熟悉的一切，陷入巨大的不习惯里，还有对于自己学习和技术的焦虑。 最开始的不习惯是，我原先的组长离职，再后来我身边的一些小伙伴的离职，再后来就是组织的调整，不过比较幸运的是，新组的小伙伴也很友好，技术很强性格也很好，很友善帮助我，所以在组里的相处还是很开心，也是我至今觉得幸运的事情，而且新组的Leader也很好，技术强并且很有趣，很有性格魅力那种。我只不过那个时候，后面更多的思绪放在了觉得不喜欢医疗业务开发上，不习惯转变为一个需求可能要和很多人去沟通去问，每天都觉得丧丧的。其实现在回想起来，按照现在的我，也没有那么不喜欢医疗开发的内容，沟通也不再胆怯，这份开发经验也很大程度的帮助了我成长以及找到现在的工作；而且现在想来，那些代码还是写的很规范很好的，用的技术栈也比较新。而且每次和组内小伙伴一起开周会时候，是很开心的，大家会说一些很有趣的梗，只是当时我自己都没有意识到这些。 这就很明显地体现到了，自己认知短浅的短板。天外有天，公司外还有公司。那时候都不知道，其实在别的公司别的代码还有跟shit 山一样的，还有那种项目老的改不动的，代码和人有一个能跑就行的，babel还在用着6的…. 有些好，只是当时不觉得有什么。有一个年轻友好的氛围，有一个能力强事不多的Leader，其实已经是上班很大的福了。 对于离别，我一直很不习惯，直到今年的8月31日，我也离职了。 和一些前司的小伙伴前后脚走，离开了之后，很长一段时间，我在很想念我过去的公司，我也很想念我过去的很多小伙伴。 我对这个从我毕业接纳了我，给了我很多包容以及成长帮助的公司，这个让我认识到很多有趣的人的公司，由衷地感谢。 心理转变 说起来这个，不得不提到，在今年年末的心理转变。在此之前，像那种受了委屈，我可以言之凿凿证明是对方做的不好，在pua我的时候，我会政治正确的将不满和实证举例，证明此事的离谱和我的委屈，好像一直以来，我在受到了明确可以证明和自己没主动关系的时候，我都会这样做。 直到今年年尾，我才意识到，这些都是没用的。 没有人一直的决策都是对的，这其中当然包括我。高位者和低位者考虑的也完全不同，每个人看到的都不是全面，那些让自己觉得很冤枉委屈的时候的领导是，我自己也是。 这些话并不是说，人就应该逆来顺受，而是很多时候的言论可能没有更大的意义，我也不应该在一开始受到委屈的时候，立马想要用语言或者自身情绪来反抗。尝试理解事情发生的根本原因，并去解决它，如果实在解决不了，那么就换一种生活或者工作方式。在这个过程中，都要尽可能用一些办法调节自己的情绪，想办法让自己在工作之余可以得到放松和释放，才能更有精力去处理解决好职场的一些问题。 人都有认知的缺陷，尤其是我认识到我在很多事情上第一次见的很不适应，让我意识到我确实见识很少，接受能力也不见的强，所以遇到事情觉得离谱荒唐的第一时间，不妨去尝试理解这个事情本身，再做决断。 这是我对自己的一些成长总结，从我这样想了之后，就心态好了很多，也可以尽可能让自己少被工作的情绪裹挟，少一些负面的能量。 新公司感受 至少在新的公司，直到现在，我都没有任何一种觉得，“这是我的新岗位啦”的感觉。 总觉得自己像是个过客，没有什么归属感，感觉自己也和它压根不熟，也不想熟，只想做好自己本分即可。 生活变化 搬家 今年从一个不大的一居室，搬到了一个一室一厅的原户型房间，没有隔断，宽敞了不少，还有地下仓储室用来放杂物，有一种正经的家的感觉。之前的姐姐临搬走前，还给我留了一整箱的纸巾、沙发垫等实用物品。经常会买一些物品装饰家里，临近过年，买了冬青和新年小挂饰，有一种过年的热闹感，回家心里也舒服很多。 还给家里添置了饮水机、洗地机等比较大的物件。 护肤 今年算是一只脚踏进了美容院，开始做一些清洁养肤等项目，一些水疗过程里还可以推背按摩，不得不说做完整个人都好舒服，很解压，皮肤也看起来很好。（果然总是能找到给自己花钱的项目… 健身 虽说健身断断续续，但是好在都有在坚持，瑜伽课现在都还没上完，因为每上一节都会感叹这动作做起来好累啊…本能地想逃避。下一次上课纯纯靠勇气。 今年上半年一直有在上健身私教课，但是饮食控制的不好，比去年控制的差很多，属于想吃什么就买了，纯纯图开心，所以减下的体重数从后半年的拐回去来看，可以是忽略不计。后面对体重也开始佛系了，健身更多图健康开心和肌肉，天天往那一坐一天，肌肉力量会变得很差，腿部肌肉力量尤其差，所以想得到改善。最喜欢的还是练背，曾经痴迷过一段时间练臀腿，被现实的酸痛教训多了就没那么喜欢了。练背主要是还能紧致脸部下颌线条，好处多多啊！背部也确实比我正面更显瘦。 下半年的私教课停掉了，一般就上上瑜伽。最近和新公司的一个小伙伴熟知之后，知道她也很喜欢健身，之前也经常在上私教课，我俩一拍即合，前段时间她送了我一张公司附近健身房的体验卡，我俩一起去练了两次，感觉很不错，决定办张卡和她一起练，这下子我还有了小伙伴了，再也不是一个人尴尬的勇闯力量区。你别说有人一起还能大大减少在健身房手机摸鱼，效率都提高了不少。上次练完我俩胳膊腿疼了一星期。 比较不错的是，到了今年冬天体重也一直在保持，没有下降但是也没有上涨，很平稳。 和家人 今年给妈妈买了我很想给她买的金耳环，买了一条珍珠项链。以及日常红包和生活费用。国庆前和她发生过一次比较大的争吵，国庆期间很伤心，也是我第一次国庆节没回家（嗯，直到今天也没有很释怀…），出去旅行散心了，去了安昌古镇、绍兴、宁波看海。不过不知道是不是心情缘故，感觉也不好玩，没有多开心，钱倒是花了不少。 宠物 今年我家稍微脆弱的暹罗猫猫，又让我带它去了两三次医院，每次花的最少6百最多2千多，不过庆幸的是之前检查出来的它的功能性肠梗阻，在复查里是没有了，只不过它确实先天的肠胃会比较脆弱，可能之前给它选的猫粮不合适，加上动物零食很多检疫不合格，这几次好像给它喂的小零食导致累积肠胃问题去了医院，后来医生建议再也不要喂任何零食，好嘛 ，这下子算是给我省钱咯。一下子省了猫零食的钱。除了喂猫粮，我就给它煮点鸡胸肉，比较健康还便宜，好在它很给面子，每次吃的很干净。 今年的我家橘橘，变得明显的更黏人更信任我了，橘橘叫五一，暹罗叫汤圆，汤圆这个冬天变黑了很多。它俩只要是我出现在哪个房间，就一定会跑到哪个房间陪我做事情，总之我在哪它俩就一定在哪，默默看着我，陪着我。别人叫他们不动，但是老母亲一叫必定跟走，这个是老母亲最欣慰的事情。今年家里多了一个新成员，一只黑白边牧。从来没有在任何公开的社交平台提过它，因为即便到今日，我仍旧不认为养它是个很正确的选择，过程中有很多后悔，甚至想过很多次，实在没能力，要不送走吧。不过我也确实很喜欢它，它也确实给我带来了开心，虽然弄的地上都是shi,让我收拾的崩溃过。不过它真的越大越懂事，可以发现它很多很乖巧懂事的地方。也对我的性格有了一定的磨练，有时候从对待它上面，我可以感受到反射出来的我的性格缺陷，或者说情感缺陷，可以让我意识到这点，我也有在慢慢改正，也是它治愈我的过程，因为即便我也有做错的时候，可是小狗每一次都会原谅我，从来都不拒绝我，它真的永远都真诚，它在给我一次一次修正的机会。不过这小子真的花了我不少大洋，养狗比养猫费钱多了，还花心思，还得经常洗澡。不过好在它相对来说，是个比较省心的小狗，还结交了很多朋友，性格稳定，还破例被选中当了一次小狗模特，给老母亲挣到了300块钱。 学习 今年为了有目标和方向的去提升自己，购买了课程，有一说一确实讲的很好，也能感受到讲课的老师的厉害和格局。 刚去看了一下记录看完了前端45节课，肯定是有成长和收获的。主要是利用下班和周末时间看的，其实我看的进度是相当慢的，因为期间看一节就可能有很多需要查漏补缺，还有就是我看时候磨蹭。 这也是我打开了解React源码的大门，还有对webpack配置的大门，还有对AST与脚手架了解的大门的开始。 其后又读完了React理念架构核心源码解读共计四章15小节，算是对照之前购买的课程学习中的源码阅读的补充学习。 学习了Dva框架的使用，这个是因为工作需要，顺便看了看，只是会用。 总的来说，至少可以说是有技术知识成长的一年。 算法基础知识概念都看了一遍，概念有记住一些，但是题还是不会做，顶多会一些固定题解法，在工作中有用到。 但是现在做算法还是很菜的，害，这点还得多做点题掌握些思路。 结束语 以上，就是今年的一个不完全总结吧。 == 你的新衣服是用来讨好自己的，你的人生也是。==","link":"/2023/12/22/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"想法","slug":"想法","link":"/tags/%E6%83%B3%E6%B3%95/"}],"categories":[{"name":"front","slug":"front","link":"/categories/front/"},{"name":"mind","slug":"mind","link":"/categories/mind/"}]}