{"pages":[{"title":"关于我：","text":"一个想混入互联网的momo,结果GitHub当初使用了全名。 个人介绍 慕溪是我过去工作的花名，我喜欢这个名字，所以你可以叫我慕溪。 98年，2021年毕业，目前从事前端开发工作，base杭州。 兴趣爱好我的兴趣爱好很广泛 喜欢养花，熟悉很多种鲜花名字 喜欢画画 想去学吉他，到现在还没开始动手 喜欢猫猫和狗狗 特点 容易一边内耗一边自我拯救 争取做一个不自我内耗的人 最近get到 互联网发疯真是个解压的事情","link":"/about/index.html"},{"title":"","text":"","link":"/links/index.html"}],"posts":[{"title":"myFirstBlog","text":"这是我的第一个博客","link":"/2023/11/02/myFirstBlog/"},{"title":"this指针、闭包、作用域","text":"this大家都在说this,this是什么？– js的运行环境。首先我们要知道，一个系统System的状态分为两种： 静态创建态 语义分析 （作用域链、变量声明） 动态执行态 this/context/指针 变量使用 函数引用 作用域链 + 上下文 面试常问作用域链，作用域链是什么？ –子可调用父的东西，作用域链向上找。 函数提升 ： 提升至当前作用域最初始 变量提升 ： 提升至当前作用域最初始 提升的优先级 ： 变量优先于函数 对于作用域链，我们直接通过创建态来定位作用域链。 this 上下文 context 我家门前有条河，门前的河上有做桥，合理有群鸭。 我家门前有条河，「这河」上有座桥，「这河」里有群鸭。 this是在执行时动态读取上下文决定的，而不是创建时 重点 - 各使用态中的指针指向 函数直接调用 - this指向的是window =&gt; 函数表达式、匿名函数、嵌套函数例： 1234function foo() { console.log('函数内部的this', this);}foo() 隐式绑定 - this指向的是调用的上一级 =&gt; 对象、数组等引用关系逻辑之上例： 123456789function fn() { console.log('隐式绑定', this.a);}const obj = { a: 1, fn}obj.fn = fn;obj.fn(); 面试题：1234567891011121314151617181920212223242526272829303132333435363738const foo = { bar: 100, fn: function() { console.log(this.bar); console.log(this); }}// 取出let fn1 = foo.fn；// 执行fn1();// 追问1：如何改变属性的指向const o1 = { text: 'o1', fn: function() { // 直接使用上下文 - 领导直接分活 console.log('o1fn_this', this); return this.text; }}const o2 = { text: 'o2', fn: function() { // 呼叫了隔壁组leader协助执行 - 部门协作 return o1.fn(); }}const o3 = { text: 'o3', fn: function() { // 直接内部构造 - 接口人制度 let fn = o1.fn; return fn(); // 最终执行 }}console.log('o1fn', o1.fn());console.log('o2fn', o2.fn());console.log('o3fn', o3.fn()); 在执行函数时，函数被上一级调用，去找发起方 直接变成公共执行时，指向全局 追问2：就是要把console.log(‘o2fn’, o2.fn())结果是o212345678910111213141516// 1. 人为干涉，改变this - bind / call / applyo1.fn.call(o2);// 2. 不许人为干涉const o1 = { text: 'o1', fn: function() { // 直接使用上下文 - 领导直接分活 console.log('o1fn_this', this); return this.text; }}const o2 = { text: 'o2', fn: o1.fn} console.log('o2fn', o2.fn()); 显式绑定（bind | apply | call）123456789101112131415function foo() { console.log('函数内部的this', this);}foo();// 使用foo.call({ a: 1});foo.apply({ a: 1})const bindFoo = foo.bind({ a: 1})bindFoo(); 追问：call、apply、bind的区别 call &lt;=&gt; apply 传参不同 依次传入/数组传入 bind &lt; = &gt; call/apply 直接返回,而bind返回修改this后的函数，需要自己去执行；这三个第一个参数都是this的指向，call和bind传参相同，多个参数依次传入的；只有apply接收的数组； call和apply都是对函数进行直接调用，而bind方法不会立即调用函数(所以要手动调用下，前两个是主动调用)，而是返回一个修改this后的函数。 追问2：bind原理 / 手写bind 原理或者手写类题目，解题思路 说明原理 - 写注释 根据注释 - 补齐代码1234567891011121314151617181920212223242526272829// 1. 需求：手写bind =&gt; bind存放位置（挂载）=&gt; Function.prototypeFunction.prototype.newBind = function() {// 2. bind是什么？=&gt; 改变运行上下文 =&gt; 传入参数：newThis + args1~argsn const _this = this; const args = Array.prototype.slice.call(arguments); const newThis = args.shift();// 3. bind要什么？=&gt; 返回一个可执行函数 =&gt; 上下文被改变了的原函数（原函数参数不变） return function() { return _this.apply(newThis, args); }}Function.prototype.newApply = function(context) { // 边缘检测 // 函数检测 if(typeof this !== 'function') { throw new Error('type error'); } // 参数检测 context = context || window; // 临时挂载 context.fn = this; // 区分传参 + 立即执行 let result = arguments[1] ? context.fn(...arguments[1]) : context.fn() // 销毁临时挂载 delete context.fn; return result;} 123456789101112131415161718192021Array.prototype.slice.call(arguments) 到底做了什么？function foo() { console.log(arguments) console.log(Array.prototype.slice.call(arguments))}foo(1,2,3)；// {0:1,1:2,2:3,length:3}// [1,2,3]因为arguments是一个array-like（类数组）对象；除了这样写，也可以使用...rest解构，也可以使用Array.from(...)console.log(Array.from('foo'));// Expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], (x) =&gt; x + x));// Expected output: Array [2, 4, 6]Array.from() 静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。slice() 方法返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变。shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 注意： 此方法改变数组的长度！ 提示: 移除数组末尾的元素可以使用pop() 方法。 new - this指向是new之后得到的实例1234567891011class Course { constructor(name) { this.name = name; console.log('构造函数中的this:', this); } test() { console.log('类方法中的this', this); }}const course = new Course('this');course.test(); 追问：类中异步方法，this有区别吗123456789101112131415161718192021class Course { constructor(name) { this.name = name; console.log('构造函数中的this:', this); } test() { console.log('类方法中的this', this); } asyncTest() { console.log('异步方法外：', this); setTimeout(function() { console.log('异步方法内', this); }, 500) ajax.get().then(res =&gt; { // 异步方法 }) }}const course = new Course('this');course.test();course.asyncTest(); 执行setTimeout时，匿名方法执行上下文，在队列中和全局执行函数效果相同 - 指向window 再追问，如何解决 - 记录this / 显式 / 箭头函数 聊完作用域、上下文 =&gt; 如何突破束缚？面试常问必问话题，什么是闭包？ 闭包：一个函数和他周围状态的引用捆绑在一起的组合闭包场景： 函数作为返回值的场景 12345678function mail() { let content = '信'; return function() { console.log(content); }}const envelop = mail();envelop(); 函数可以作为返回值传递的 函数外部可以通过一定方式获取到内部局部作用域的变量 =&gt; 导致内部局部变量不能被GC 函数作为参数的时候 123456789101112// 单一职责let content;// 通用存储function envelop(fn) { content = 1; fn()}// 业务逻辑function mail() { console.log(content);}envelop(mail); 函数嵌套 123456789let counter = 0;function outerFn() { function innerFn() { counter++; console.log(counter); } return innerFn;}outerFn()(); 事件处理（异步）的闭包 12345678let lis = document.getElementsByTagName('li');for(var i = 0; i&lt;lis.length; i++) { (function(i) { lis[i].onclick = function() { console.log(i); } })(i);} 追问：立即执行函数 / 立即执行嵌套 =&gt; 拥有独立作用域 12345(function immediateA(a) { return (function immediateB(b) { console.log(a); })(1);})(0); 推动了js的模块化发展 实现私有变量 - 高频1234567891011121314151617181920212223function createStack() { return { items: [], push(item) { this.items.push(item); } }}const stack = { items: [], push: function() {}}function createStack() { const items = []; return { push(item) { items.push(item); } setItems() {}, getItems() {} }}","link":"/2023/11/02/this/"},{"title":"【心情】情绪边界","text":"1.知道自己的边界在哪，明白自己的情绪反应，尊重边界，而不是去合理化这个感觉。否则这个反馈体系就没有意义了，万劫不复。对方给你的暴力要反馈出来。 当对方给你的暴力，你没有表达出来的时候，你就会反过头来伤害自己。 2.信任自己的情绪。当你觉得不适的时候，就要告诉自己:你的边界被侵犯了。 3.交流的意义不是在于说我们要去辩论谁到底是拥有真理的，而是说我们一起交流我们才能把自己的想法变得更清晰一些。 4.我们的存在先于意义，我所做的才是意义所在。我在表达观点，并不意味着我是一个什么样的人。","link":"/2023/11/02/mind-20231102/"},{"title":"【心情】技术博客出现的第二天，变日记博","text":"昨天晚上更了一篇博客之后，发现写一篇真累，我归结为我不太熟悉Markdown语法，来回调整样式真麻烦。 于是今天我发现了好几个很方便可视化编辑文档之后，直接可以复制出来md格式的，实际上很多笔记软件现在应该都支持这样的，我在这里首推一下有道云。 但是，仍旧觉得写一篇技术文好累的感觉。主要还是我菜，知识并不连贯的，贴出来的代码，我也不一定能再默写出来一遍。 所以，最近来说，可能它会是一个日记博客的可能性更大一些。 记录一些心情也没什么不好，虽说这样我发微博也一样。 不过这样想想，技术笔记不发博客，记在我自己有道云或者掘金那也一样吼。","link":"/2023/11/03/mind-20231103/"}],"tags":[{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"想法","slug":"想法","link":"/tags/%E6%83%B3%E6%B3%95/"}],"categories":[{"name":"front","slug":"front","link":"/categories/front/"},{"name":"mind","slug":"mind","link":"/categories/mind/"}]}